这里整理了《Java编程思想(第4版)》里的内容<br/>
**初始化与清理<br/>**
`构造器`<br/>
    不接受任何参数的构造器叫做默认构造器，Java文档中通常使用术语无参构造器。如果已定义了一个构造器(无论是否有参数)，编译器就不会帮你自动创建默认构造器。在Java中，“初始化”和“创建”捆绑在一起，两者不能分离。<br/>
    方法重载<br/>
`方法名相同而形式参数不同。`<br/>
    如果传入的数据类型(实际参数类型)小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。<br/>
    如果传入的实际参数大于重载方法声明的形式参数，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。<br/>
`this关键字`<br/>
    this可指“这个对象”或“当前对象”。可以用this调用一个构造器，但却不能调用两个。此外，必须将两个狗傲气调用治愈最起始处，否则编译器会报错。除构造器之外，编译器禁止在其他任何方法中调用构造器。<br/>
`清理：终结处理和垃圾回收`<br/>
    finalize()一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。<br/>
    对象可能不被垃圾回收。<br/>
    垃圾回收只与内存有关。<br/>
    构造器初始化<br/>
`对象的创建过程`<br/>
    1.即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建一个类的对象是，或者是这个类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位类文件。<br/>
    2.然后载入类文件。有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。<br/>
    3.当用new创建对象的时候，首先将在堆上为对象分配足够的存储空间。<br/>
    4.这块存储空间会被清零，基本类型数据都设置成了默认值，而引用责备设置成了null。<br/>
    5.执行所有出现于字段定义出的初始化动作。<br/>
    6.执行构造器。<br/>
**访问控制权限<br/>**
`包：库单元`<br/>
每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的。<br/>
`Java访问权限修饰词`<br/>
public:无论是谁，无论在哪里，都可以访问改成员。
不加访问修饰符:放置同一个包内的方式给成员赋予包访问权。其它包内的其他类也就可以访问改成员了。<br/>
protected:包内可访问；包外继承的可访问。<br/>
private:私有。<br/>
`接口和实现`<br/>
在Jdk1.8之前，接口的方法只能是public abstract的；变量必须是public static final的。<br/>
从Jdk1.8开始，接口可以有static方法和default方法。static只能通过接口名调用，default方法只能通过实现了接口的类的对象调用。一个类实现的不同接口可以有相同的static方法；如果有相同的default方法，类需要覆盖该方法，否则编译失败。<br/>
`类的访问权限`<br/>
public和不加访问修饰符。<br/>
**复用类<br/>**
**多态<br/>**
**接口<br/>**
**内部类<br/>**
**容器<br/>**
**异常<br/>**
**字符串<br/>**
**类型信息<br/>**
**泛型<br/>**
**数组<br/>**
**Java I/O系统<br/>**
`File类`<br/>
`输入和输出`<br/>
`添加属性和有用的接口`<br/>
`Reader和Writer`<br/>
`自我独立的类：RandomAccessFile`<br/>
`I/O流的典型使用方式`<br/>
`文件读写的实用工具`<br/>
`标准I/O`<br/>
`进程控制`<br/>
`新I/O`<br/>
ByteBuffer是唯一直接与通道交互的缓冲器。<br/>
FileInputStream、FileOutputStream以及RandomAccessFile被修改，有getChannel()方法，返回FileChannel(通道)。<br/>

`压缩`<br/>
`对象序列化`<br/>
**枚举<br/>**
**注解<br/>**
